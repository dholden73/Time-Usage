WITH calendar AS (
    SELECT
        period_start,
        period_end,
        date::date AS date,
        year,
        month,
        day
    FROM datamart.cal_days
    WHERE year = EXTRACT(YEAR FROM CURRENT_DATE)
),
ec AS (
  SELECT
    ec.equipment_capability_sk,
    ec.start_time,
    ec.end_time,
    ec.entity_type,
    ec.entity_sk,
    ec.entity_id,
    ec.version,
    ec.description,
    ec.hierarchy_scope,
    ec.equipment_ids[1]       AS equipment_id,
    ec.equipment_class_ids[1] AS equipment_class_id,
    ec.equipment_use,
    ec.capability_type,
    ec.reason,
    ec.record_time,
    ec.source_system,
    ec.ingestion_reference_sk
  FROM dw.equipment_capability ec
),
props AS (
  SELECT
    p.entity_sk,
    p.id,
    p.value,
    p.unit_of_measure,
    p.data_type,
    p.property_sk,
    ROW_NUMBER() OVER (
      PARTITION BY p.entity_sk, p.id
      ORDER BY p.property_sk DESC
    ) AS rn
  FROM dw.property p
  WHERE p.id ilike 'Time Usage Category'
),
ec_property AS (
  SELECT
    ec.equipment_capability_sk,
    ec.start_time,
    ec.end_time,
    ec.hierarchy_scope,
    ec.equipment_id,
    ec.equipment_class_id,
    ec.equipment_use,
    ec.capability_type,
    ec.reason,
    ec.record_time,
    ec.source_system,
    ec.ingestion_reference_sk,
    tuc.value  AS "Time Usage Category"
  FROM ec
  LEFT JOIN props tuc 
  ON tuc.entity_sk = ec.equipment_capability_sk AND tuc.id = 'Time Usage Category' AND tuc.rn = 1
),
op_data AS (
  SELECT
    ep.equipment_id AS "equipId",
    ep.equipment_class_id,
    NULL::text AS "shift",
    ep.start_time AS "startTime",
    ep.end_time   AS "endTime",
    ep.equipment_use AS "equipmentUse",
    ep.reason AS "reasonCode",
    ep."Time Usage Category" AS "timeUsageCategory_raw",
    GREATEST(
      0,
      EXTRACT(EPOCH FROM (COALESCE(ep.end_time, ep.start_time) - ep.start_time))
    )::bigint AS "Duration",
    NULL::numeric AS "distance_travelled",
    NULL::numeric AS "distanceTravelledState"
  FROM ec_property ep
),
final AS (
  SELECT
    "equipId",
    equipment_class_id,
    "shift",
    "startTime",
    "endTime",
    "equipmentUse",
    "reasonCode",
    "timeUsageCategory_raw",
    regexp_replace("timeUsageCategory_raw", '.*\|', '') AS "timeUsageCategory",
    "Duration",
    CASE
      WHEN regexp_replace("timeUsageCategory_raw", '.*\|', '') ILIKE 'breakdown'
        THEN 1
      ELSE 0
    END AS BreakDown_eventCount
  FROM op_data
),
-- Apportion split events across shift-hours (calendar rows)
apportioned AS (
  SELECT
    c.*,
    s."equipId",
    s.equipment_class_id AS equipment_class,
    s."shift",
    s."equipmentUse",
    s."reasonCode",
    s."timeUsageCategory_raw",
    s."timeUsageCategory",
    s.BreakDown_eventCount,
    GREATEST(s."startTime", c.period_start) AS split_start,
    LEAST(COALESCE(s."endTime", s."startTime"), c.period_end) AS split_end,
    EXTRACT(
      EPOCH FROM (
        LEAST(COALESCE(s."endTime", s."startTime"), c.period_end)
        - GREATEST(s."startTime", c.period_start)
      )
    )::bigint AS apportioned_duration_sec
  FROM calendar c
  left JOIN final s
    ON s."startTime" < c.period_end
   AND COALESCE(s."endTime", s."startTime") > c.period_start
),
daily AS (
  SELECT
    "equipId" as equipId,
    equipment_class,
    date,
    period_start,
    period_end,
    -- total time (hours) for the day
    SUM(apportioned_duration_sec) / 3600.0 AS duration_hours,
    SUM(
       CASE
          WHEN "timeUsageCategory" ILIKE 'breakdown'
          THEN apportioned_duration_sec
          ELSE 0
       END
    ) / 3600.0 AS breakdown_hours,   
    -- breakdown downtime (hours) for the day
    sum(BreakDown_eventCount) as BreakDown_eventCount
  FROM apportioned
  GROUP BY "equipId", equipment_class, date, period_start, period_end
 )
  SELECT
    equipId,
    equipment_class,
    date,
    duration_hours,
    breakdown_hours,
    breakdown_eventcount,
    SUM(duration_hours) OVER (
    PARTITION BY equipId
    ORDER BY date
    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
  ) AS duration_hours_30d,
  SUM(breakdown_hours) OVER (
    PARTITION BY equipId
    ORDER BY date
    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
  ) AS breakdown_hours_30d,
  SUM(breakdown_eventcount) OVER (
    PARTITION BY equipId
    ORDER BY date
    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
  ) AS breakdown_eventcount_30d,
  --30-day rolling MTBF/MTTR computed from rolling sums
  ( SUM(duration_hours) OVER (
      PARTITION BY equipId
      ORDER BY date
      ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    )
    -
    SUM(breakdown_hours) OVER (
      PARTITION BY equipId
      ORDER BY date
      ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    )
  )
  / NULLIF(
    SUM(breakdown_eventcount) OVER (
      PARTITION BY equipId
      ORDER BY date
      ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ), 0
  ) AS MTBF,
  SUM(breakdown_hours) OVER (
    PARTITION BY equipId
    ORDER BY date
    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
  )
  / NULLIF(
    SUM(breakdown_eventcount) OVER (
      PARTITION BY equipId
      ORDER BY date
      ROWS BETWEEN 29 PRECEDING AND CURRENT ROW
    ), 0
  ) AS MTTR
FROM daily
--WHERE equipment_class ILIKE 'bogger'
ORDER BY date
